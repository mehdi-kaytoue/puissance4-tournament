:- dynamic board/1.

% --- Gestion du plateau ---

getFreeColumns(Board, FreeCols) :-
    findall(Index, (nth1(Index, Board, Col), member('_', Col)), FreeCols).

simulateMove(Board, ColIndex, Player, SimulatedBoard) :-
    nth1(ColIndex, Board, Col),
    placeInColumn(Col, Player, NewCol),
    replace(Board, ColIndex, NewCol, SimulatedBoard).

placeInColumn(Col, Player, NewCol) :-
    reverse(Col, RevCol),
    placeInReversedColumn(RevCol, Player, NewRevCol),
    reverse(NewRevCol, NewCol).

placeInReversedColumn([H|T], Player, [Player|T]) :- H = '_', !.
placeInReversedColumn([H|T], Player, [H|R]) :-
    placeInReversedColumn(T, Player, R).

replace([_|T], 1, X, [X|T]).
replace([H|T], N, X, [H|R]) :-
    N > 1, N1 is N - 1, replace(T, N1, X, R).

changePlayer('x','o').
changePlayer('o','x').

% --- Victoire ---
win(Player, Board) :-
    horizontal_win(Board, Player);
    vertical_win(Board, Player);
    diagonal_asc(Board, Player);
    diagonal_desc(Board, Player).

horizontal_win(Board, Player) :-
    member(Row, Board),
    consecutive_four(Row, Player).

vertical_win(Board, Player) :-
    transpose(Board, T),
    member(Col, T),
    consecutive_four(Col, Player).

% generated by IA ---
diagonal_asc(Board, Player) :-
    between(1,4,ColIndex), between(1,3,RowIndex),
    nth1(ColIndex, Board, C1), nth1(RowIndex, C1, Player),
    Col2 is ColIndex+1, Row2 is RowIndex+1, nth1(Col2, Board, C2), nth1(Row2, C2, Player),
    Col3 is ColIndex+2, Row3 is RowIndex+2, nth1(Col3, Board, C3), nth1(Row3, C3, Player),
    Col4 is ColIndex+3, Row4 is RowIndex+3, nth1(Col4, Board, C4), nth1(Row4, C4, Player).

diagonal_desc(Board, Player) :-
    between(1,4,ColIndex), between(4,6,RowIndex),
    nth1(ColIndex, Board, C1), nth1(RowIndex, C1, Player),
    Col2 is ColIndex+1, Row2 is RowIndex-1, nth1(Col2, Board, C2), nth1(Row2, C2, Player),
    Col3 is ColIndex+2, Row3 is RowIndex-2, nth1(Col3, Board, C3), nth1(Row3, C3, Player),
    Col4 is ColIndex+3, Row4 is RowIndex-3, nth1(Col4, Board, C4), nth1(Row4, C4, Player).
% -------- end generated by IA ---

consecutive_four([P,P,P,P|_], P) :- !.
consecutive_four([_|T], P) :- consecutive_four(T, P).


% Generated by IA ---
transpose([], []).
transpose([[]|_], []) :- !.
transpose(Matrix, [Row|Rows]) :-
    maplist(nth1(1), Matrix, Row),
    maplist(tl, Matrix, Rest),
    transpose(Rest, Rows).
tl([_|T], T).
% -------- end generated by IA ---

% Simple AI random
ia(Board, Move) :-
    random_between(1, 7, Move),
    nth1(Move, Board, Col),
    member('_', Col), !.
ia(Board, Move) :-
    ia(Board, Move).
% -------------

% -------------
% Defensive AI
%. 1. Joue un coup gagnant si possible.
%. 2. Sinon, bloque une victoire adverse.
iaDefensive(Board, Move, Player) :-
    getFreeColumns(Board, FreeCols),
    member(Move, FreeCols),
    changePlayer(Player, Opponent),
    simulateMove(Board, Move, Opponent, SimulatedBoard),
    win(Opponent, SimulatedBoard), !.

iaDefensive(Board, Move, _) :-
    ia(Board, Move).
% -------------

% --- IA Mixte ---
%. 1. Joue un coup gagnant si possible.
%. 2. Si possible, bloque une victoire adverse.
%. 3. Sinon, joue un coup aléatoire.
iaMixte(Board, Move, Player) :-
    getFreeColumns(Board, FreeCols),
    member(Move, FreeCols),
    simulateMove(Board, Move, Player, SimulatedBoard),
    win(Player, SimulatedBoard), !.

iaMixte(Board, Move, Player) :-
    getFreeColumns(Board, FreeCols),
    member(Move, FreeCols),
    changePlayer(Player, Opponent),
    simulateMove(Board, Move, Opponent, SimulatedBoard),
    win(Opponent, SimulatedBoard), !.

iaMixte(Board, Move, _) :-
    getFreeColumns(Board, FreeCols),
    random_member(Move, FreeCols).

% --- IA stratégique 

scoreBoard(Board, Player, Score) :-
    scoreAlign(Board, Player, 2, S2),
    scoreAlign(Board, Player, 3, S3),
    scoreAlign(Board, Player, 4, S4),
    Score is S2 + S3*10 + S4*100.

scoreAlign(Board, Player, Len, Count) :-
    findall(1, (member(L, Board), consecutive(L, Player, Len)), Ls),
    length(Ls, Count1),
    transpose(Board, T),
    findall(1, (member(C, T), consecutive(C, Player, Len)), Lc),
    length(Lc, Count2),
    Count is Count1 + Count2.

% generated by IA ---
consecutive(List, Player, Len) :-
    append(_, Sub, List), length(Sub, Len), maplist(=(Player), Sub).
% -------- end generated by IA ---

bestScoreMove([_-M], M) :- !.
bestScoreMove([S1-C1,S2-C2|Rest], Best) :-
    (S1 >= S2 -> bestScoreMove([S1-C1|Rest], Best)
               ; bestScoreMove([S2-C2|Rest], Best)).

% IA stratégique 3
% 1. Joue un coup gagnant si possible.
% 2. Sinon, bloque une victoire adverse.
% 3. Sinon, évalue tous les coups possibles avec heuristique et choisit le meilleur sur une profondeur 2.
iaStrategique3(Board, Move, Player) :-
    getFreeColumns(Board, FreeCols),
    ( member(Move, FreeCols),
      simulateMove(Board, Move, Player, B),
      win(Player, B) -> true
    ;
      changePlayer(Player, Opp),
      member(Move, FreeCols),
      simulateMove(Board, Move, Opp, B),
      win(Opp, B) -> true
    ;
      findall(Score-Col,
    (
        member(Col, FreeCols),
        simulateMove(Board, Col, Player, B1),
        changePlayer(Player, Opp),
        getFreeColumns(B1, OppCols),
        % generated by IA ---
        findall(S2,
            (member(OC, OppCols),
             simulateMove(B1, OC, Opp, B2),
             scoreBoard(B2, Player, S2)),
            OppScores),
        (OppScores == [] -> Score = 0; min_list(OppScores, Score))
        % -------- end generated by IA ---
    ),
    Scores),
    bestScoreMove(Scores, Move)
    ).

joue_coup(Board, Joueur, Col) :-
    iaStrategique3(Board, Col, Joueur),
    format('~w~n', [Col]).
